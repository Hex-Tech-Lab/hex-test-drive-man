#!/usr/bin/env python3
"""
Generate SQL UPDATE statements to map extracted vehicle images to database models.

Usage:
    python3 scripts/generate_image_updates.py > scripts/update_image_urls.sql

Requires:
    - SUPABASE_URL environment variable
    - SUPABASE_ANON_KEY environment variable
"""

import os
import sys
import json
import re
from pathlib import Path
from urllib.request import Request, urlopen
from urllib.error import HTTPError, URLError

# Configuration
PROJECT_ROOT = Path(__file__).parent.parent
HERO_DIR = PROJECT_ROOT / "public/images/vehicles/hero"
HOVER_DIR = PROJECT_ROOT / "public/images/vehicles/hover"

# Get Supabase credentials
SUPABASE_URL = os.environ.get('SUPABASE_URL', 'https://lbttmhwckcrfdymwyuhn.supabase.co')
SUPABASE_ANON_KEY = os.environ.get('SUPABASE_ANON_KEY')

if not SUPABASE_ANON_KEY:
    print("-- ERROR: SUPABASE_ANON_KEY not set", file=sys.stderr)
    print("-- Run: source scripts/supabase_helper.sh", file=sys.stderr)
    print("-- Or: export SUPABASE_ANON_KEY='your_key'", file=sys.stderr)
    sys.exit(1)


def query_supabase(table, select_fields, filters=None):
    """Query Supabase REST API."""
    url = f"{SUPABASE_URL}/rest/v1/{table}?select={select_fields}"

    if filters:
        for key, value in filters.items():
            url += f"&{key}=eq.{value}"

    req = Request(url)
    req.add_header('apikey', SUPABASE_ANON_KEY)
    req.add_header('Authorization', f'Bearer {SUPABASE_ANON_KEY}')

    try:
        with urlopen(req) as response:
            return json.loads(response.read().decode())
    except (HTTPError, URLError) as e:
        print(f"-- ERROR querying {table}: {e}", file=sys.stderr)
        return []


def parse_filename(filename):
    """
    Parse image filename to extract brand, model, year.

    Examples:
        Audi-q3-2024-25.jpg -> (Audi, q3, 2024-25)
        BMW-x5-lci-2024.jpg -> (BMW, x5 lci, 2024)
        Chery-tiggo-4-pro-2025.jpg -> (Chery, tiggo 4 pro, 2025)
    """
    # Remove .jpg extension
    name = filename.replace('.jpg', '').replace('.JPG', '')

    # Split on hyphens
    parts = name.split('-')

    if len(parts) < 3:
        return None, None, None

    # First part is always brand
    brand = parts[0]

    # Last part is year (or year range like 2024-25)
    year = parts[-1]

    # Middle parts are model name
    model = ' '.join(parts[1:-1])

    return brand, model, year


def normalize_brand_name(brand):
    """Normalize brand name for database matching."""
    # Handle common variations
    brand_map = {
        'Mercedes-benz': 'Mercedes-Benz',
        'Mercedes': 'Mercedes-Benz',
        'Bmw': 'BMW',
        'Kia': 'Kia',
        'Hyundai': 'Hyundai',
        'Toyota': 'Toyota',
        'Chevrolet': 'Chevrolet',
        'Chery': 'Chery',
        'Nissan': 'Nissan',
        'Audi': 'Audi',
        'Volkswagen': 'Volkswagen',
        'Vw': 'Volkswagen',
    }
    return brand_map.get(brand, brand)


def normalize_model_name(model):
    """Normalize model name for flexible matching."""
    # Convert to lowercase for comparison
    normalized = model.lower()

    # Remove common suffixes/prefixes for matching
    normalized = re.sub(r'\s+(lci|facelift|fl|facelifted)$', '', normalized)

    return normalized


def find_matching_models(brand, model, year):
    """
    Find matching models in database.

    Returns list of model IDs with their current image URLs.
    """
    # Get brand ID first
    brands = query_supabase('brands', 'id,name', {'name': brand})

    if not brands:
        print(f"-- WARNING: Brand not found: {brand}", file=sys.stderr)
        return []

    brand_id = brands[0]['id']

    # Query models for this brand
    models = query_supabase(
        'models',
        'id,name,hero_image_url,hover_image_url',
        {'brand_id': brand_id}
    )

    # Normalize search model name
    search_model = normalize_model_name(model)

    # Find best matches
    matches = []
    for db_model in models:
        db_model_name = normalize_model_name(db_model['name'])

        # Exact match
        if db_model_name == search_model:
            matches.append(db_model)
            continue

        # Partial match (model name contains search or vice versa)
        if search_model in db_model_name or db_model_name in search_model:
            matches.append(db_model)

    return matches


def generate_sql():
    """Generate SQL UPDATE statements for all images."""
    print("-- Generated by scripts/generate_image_updates.py")
    print("-- Run with: psql $SUPABASE_URL < scripts/update_image_urls.sql")
    print()
    print("BEGIN;")
    print()

    # Track statistics
    stats = {
        'hero_found': 0,
        'hover_found': 0,
        'hero_missing': 0,
        'hover_missing': 0,
        'updates': 0
    }

    # Process hero images
    if HERO_DIR.exists():
        hero_files = sorted(HERO_DIR.glob('*.jpg'))
        print(f"-- Processing {len(hero_files)} hero images")
        print()

        for img_path in hero_files:
            filename = img_path.name
            brand, model, year = parse_filename(filename)

            if not brand or not model:
                print(f"-- SKIP: Could not parse {filename}", file=sys.stderr)
                continue

            brand = normalize_brand_name(brand)
            matches = find_matching_models(brand, model, year)

            if not matches:
                print(f"-- WARNING: No match for {filename} ({brand} {model})", file=sys.stderr)
                stats['hero_missing'] += 1
                continue

            if len(matches) > 1:
                print(f"-- INFO: Multiple matches for {filename}:", file=sys.stderr)
                for m in matches:
                    print(f"--   - {m['name']} (id: {m['id']})", file=sys.stderr)

            # Generate UPDATE for each match
            for match in matches:
                model_id = match['id']
                model_name = match['name']
                url_path = f"/images/vehicles/hero/{filename}"

                print(f"-- Update hero image: {model_name}")
                print(f"UPDATE models SET hero_image_url = '{url_path}' WHERE id = '{model_id}';")
                print()

                stats['hero_found'] += 1
                stats['updates'] += 1

    # Process hover images
    if HOVER_DIR.exists():
        hover_files = sorted(HOVER_DIR.glob('*.jpg'))
        print(f"-- Processing {len(hover_files)} hover images")
        print()

        for img_path in hover_files:
            filename = img_path.name
            brand, model, year = parse_filename(filename)

            if not brand or not model:
                print(f"-- SKIP: Could not parse {filename}", file=sys.stderr)
                continue

            brand = normalize_brand_name(brand)
            matches = find_matching_models(brand, model, year)

            if not matches:
                print(f"-- WARNING: No match for {filename} ({brand} {model})", file=sys.stderr)
                stats['hover_missing'] += 1
                continue

            if len(matches) > 1:
                print(f"-- INFO: Multiple matches for {filename}:", file=sys.stderr)
                for m in matches:
                    print(f"--   - {m['name']} (id: {m['id']})", file=sys.stderr)

            # Generate UPDATE for each match
            for match in matches:
                model_id = match['id']
                model_name = match['name']
                url_path = f"/images/vehicles/hover/{filename}"

                print(f"-- Update hover image: {model_name}")
                print(f"UPDATE models SET hover_image_url = '{url_path}' WHERE id = '{model_id}';")
                print()

                stats['hover_found'] += 1
                stats['updates'] += 1

    print("COMMIT;")
    print()
    print("-- Statistics:")
    print(f"--   Hero images matched: {stats['hero_found']}")
    print(f"--   Hero images unmatched: {stats['hero_missing']}")
    print(f"--   Hover images matched: {stats['hover_found']}")
    print(f"--   Hover images unmatched: {stats['hover_missing']}")
    print(f"--   Total UPDATE statements: {stats['updates']}")

    # Print summary to stderr
    print(f"\nSummary: {stats['updates']} updates generated", file=sys.stderr)
    print(f"  Hero: {stats['hero_found']}/{stats['hero_found'] + stats['hero_missing']}", file=sys.stderr)
    print(f"  Hover: {stats['hover_found']}/{stats['hover_found'] + stats['hover_missing']}", file=sys.stderr)


if __name__ == '__main__':
    generate_sql()
